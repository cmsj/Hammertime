//
//  HTScreen.swift
//  Hammertime
//
//  Created by Chris Jones on 20/10/2021.
//

import Cocoa
import OSLog

struct HTGammaPoint {
    var red: Float
    var green: Float
    var blue: Float
}

@objc
class HTScreen: NSObject {
    // MARK: - Simple properties
    private static let screenIDKey = NSDeviceDescriptionKey(rawValue: "NSScreenNumber")
    let screen: NSScreen
    let log: Logger

    // MARK: - Initialiser
    init(_ screen: NSScreen) {
        self.screen = screen
        log = Logger(subsystem: "org.hammerspoon.Hammertime", category: "HTScreen")
        log.debug("Initialised HTScreen for: \(screen.localizedName)")
    }

    // MARK: - Overrides
    // HTScreen objects are intended to be fairly transient and completely stateless, so we conside them equal if they represent the same underlying NSScreen.
    override func isEqual(_ object: Any?) -> Bool {
        if let object = object as? HTScreen {
            return object.id == self.id
        }
        return false
    }

    // MARK: - Computed properties
    /// Numerical ID for this screen. Generated by macOS and not guaranteed to be stable across screen reconfigurations or reboots
    var id: CGDirectDisplayID {
        get {
            return screen.deviceDescription[HTScreen.screenIDKey] as? CGDirectDisplayID ?? 0
        }
    }
    /// UUID for this screen. Generated by macOS and not guaranteed to be stable across screen reconfigurations or reboots
    var uuid: UUID {
        get {
            return UUID.init(cfUUID: CGDisplayCreateUUIDFromDisplayID(id).takeRetainedValue())
        }
    }
    /// Name of the screen. Typically taken from EDID values where available
    var name: String {
        get {
            screen.localizedName
        }
    }
    /// Frame of the screen
    var frame: NSRect {
        get {
            screen.frame
        }
    }
    /// Frame of the screen not including the menubar and dock
    var visibleFrame: NSRect {
        get {
            screen.visibleFrame
        }
    }
    /// Background image of the screen
    var backgroundImage: URL? {
        get {
            NSWorkspace.shared.desktopImageURL(for: screen)
        }
        set {
            do {
                if (newValue != nil) {
                    log.debug("Attempting to set desktop image for \(self.id):\(self.name): \(newValue.debugDescription)")
                    try NSWorkspace.shared.setDesktopImageURL(newValue!, for: screen)
                }
            } catch {
                log.error("Unable to set desktop image for \(self.id):\(self.name): \(error.localizedDescription)")
            }
        }
    }
    /// Fetch an NSImage snapshot of the whole screen
    func snapshot() -> NSImage? {
        return snapshotForRect(rect: NSMakeRect(0, 0, screen.frame.width, screen.frame.height))
    }

    /// Fetch an NSImage snapshot of a region of the screen
    func snapshotForRect(rect: NSRect) -> NSImage? {
        if let cgImage = CGDisplayCreateImage(id, rect: rect) {
            return NSImage(cgImage: cgImage, size: NSZeroSize)
        } else {
            log.error("Unable to generate snapshot for: \(self.id):\(self.name) \(rect.debugDescription)")
            return nil
        }
    }

    /// Make this screen a mirror of another screen
    /// - Parameters:
    ///   - aScreen: The screen that this screen should copy
    ///   - permanent: If true, screen mirroring is configured permanently. If false, screen mirroring will be forgotten when logging out.
    /// - Returns: True if mirroring was started correctly, otherwise False
    func becomeMirrorTarget(_ aScreen: HTScreen, permanent: Bool = false) -> Bool {
        var config: CGDisplayConfigRef?
        var result: CGError

        CGBeginDisplayConfiguration(&config)
        result = CGConfigureDisplayMirrorOfDisplay(config, id, aScreen.id)
        if (result != .success) {
            CGCancelDisplayConfiguration(config)
            log.error("Unable to initiate mirroring of \(aScreen.id):\(aScreen.name) to \(self.id):\(self.name): \(result.rawValue)")
            return false
        }
        CGCompleteDisplayConfiguration(config, permanent ? CGConfigureOption.permanently : CGConfigureOption.forSession)
        return true
    }

    /// If this screen is acting as a mirror of another screen, this contains an HTScreen for the source screen
    var mirrorSource: HTScreen? {
        get {
            let sourceID = CGDisplayMirrorsDisplay(id)

            return HTScreenManager.allScreens().first { aScreen in
                aScreen.id == sourceID
            }
        }
    }

    /// Stops this screen mirroring another screen
    /// - Parameter permanent: If true, screen mirroring is removed permanently. If false, screen mirroring will resume after logging out
    /// - Returns: True if mirroring was stopped correctly, otherwise False
    func mirrorStop(permanent: Bool = false) -> Bool {
        var config: CGDisplayConfigRef?
        var result: CGError

        CGBeginDisplayConfiguration(&config)
        result = CGConfigureDisplayMirrorOfDisplay(config, id, kCGNullDirectDisplay)
        if (result != .success) {
            CGCancelDisplayConfiguration(config)
            log.error("Unable to stop mirroring of \(self.id):\(self.name): \(result.rawValue)")
            return false
        }
        CGCompleteDisplayConfiguration(config, permanent ? CGConfigureOption.permanently : CGConfigureOption.forSession)
        return true
    }

    /// Sets the origin of this screen within the global screen coordinate space. The origin of the primary screen is (0,0). The new origin set here is placed as close as possible to the requested location, without overlapping or leaving a gap between screens. Note that if this screen is part of a mirrored set, the mirroring may be removed
    /// - Parameters:
    ///   - x: The desired X coordinate for the upper-left corner of this screen
    ///   - y: The desired Y coordinate for the upper-left corner of this screen
    /// - Returns: True if the origin was set, otherwise False
    func setOrigin(x: Int32, y: Int32) -> Bool {
        var config: CGDisplayConfigRef?
        var result: CGError

        CGBeginDisplayConfiguration(&config)
        result = CGConfigureDisplayOrigin(config, id, x, y)
        if (result != .success) {
            CGCancelDisplayConfiguration(config)
            log.error("Unable to set origin of \(self.id):\(self.name) to (\(x),\(y)): \(result.rawValue)")
            return false
        }
        CGCompleteDisplayConfiguration(config, .permanently)

        // FIXME: Log errors
        return result == .success
    }

    /// Sets this screen as the primary screen (ie the screen whose top left is at (0,0) in the global screen coordinates space).
    /// - Returns: True if the operation succeded, otherwise false
    func setPrimary() -> Bool {
        if (CGMainDisplayID() == id) {
            // noop, we are already the main screen
            log.debug("Ignoring setPrimary() on \(self.id):\(self.name) - we are already primary")
            return true;
        }

        var config: CGDisplayConfigRef?
        var result: CGDisplayErr
        var screenCount: UInt32 = 0

        result = CGGetOnlineDisplayList(0, nil, &screenCount)
        if (result != .success) {
            log.error("Unable to fetch online display list count: \(result.rawValue)")
            return false
        }
        var onlineScreens: [CGDirectDisplayID] = Array(repeating: 0, count: Int(screenCount))
        result = CGGetOnlineDisplayList(screenCount, &onlineScreens, &screenCount)
        if (result != .success) {
            log.error("Unable to fetch online display list: \(result.rawValue)")
            return false
        }

        let deltaX = -CGDisplayBounds(id).minX
        let deltaY = -CGDisplayBounds(id).minY

        CGBeginDisplayConfiguration(&config)

        for dID in onlineScreens {
            if (dID) == 0 {
                continue
            }
            result = CGConfigureDisplayOrigin(config, dID,
                                            Int32(CGDisplayBounds(dID).minX + deltaX),
                                            Int32(CGDisplayBounds(dID).minY + deltaY))
            if (result != .success) {
                CGCancelDisplayConfiguration(config)
                log.error("Unable to configure display origin for: \(dID): \(result.rawValue)")
                return false
            }
        }

        CGCompleteDisplayConfiguration(config, .forSession)
        return true
    }

    /// Set the gamma of the screen
    /// - Parameters:
    ///   - whitepoint: An HTGammaPoint containing float values for the red/green/blue values of the desired white point of the screen
    ///   - blackpoint: An HTGammaPoint containing float values for the red/green/blue values of the desired black point of the screen
    /// - Returns: True if the operation succeeded, otherwise False
    func setGamma(whitepoint: HTGammaPoint, blackpoint: HTGammaPoint) -> Bool {
        guard let originalGamma = HTScreenManager.shared.getCachedGammasForScreen(id, cacheType: .original) else {
            log.error("Unable to fetch initial cached gammas for: \(self.id):\(self.name)")
            return false
        }

        let originalReds   = originalGamma.red
        let originalGreens = originalGamma.green
        let originalBlues  = originalGamma.blue

        let count = originalReds.count

        var redTable   = [CGGammaValue](repeating: 0, count: count)
        var greenTable = [CGGammaValue](repeating: 0, count: count)
        var blueTable  = [CGGammaValue](repeating: 0, count: count)

        for i in 0..<count {
            redTable[i] = blackpoint.red + (whitepoint.red - blackpoint.red) * originalReds[i]
            greenTable[i] = blackpoint.green + (whitepoint.green - blackpoint.green) * originalGreens[i]
            blueTable[i] = blackpoint.blue + (whitepoint.blue - blackpoint.blue) * originalBlues[i]
        }
        HTScreenManager.shared.cacheGammasForScreen(HTGammaTable(id: id, red: redTable, green: greenTable, blue: blueTable), cacheType: .current)

        let result = CGSetDisplayTransferByTable(id, UInt32(count), redTable, greenTable, blueTable)
        if (result != .success) {
            log.error("Unable to set gammas for: \(self.id):\(self.name): \(result.rawValue)")
            return false
        }

        return true
    }

    // MARK: - Private API use beyond this point

    /// Get or set the rotation of the screen. Valid values are: 0, 90, 180, 270
    var rotation: Int {
        get {
            Int(CGDisplayRotation(id))
        }
        set {
            var rotation: Int
            switch (newValue) {
            case 0:
                rotation = kIOScaleRotate0
            case 90:
                rotation = kIOScaleRotate90
            case 180:
                rotation = kIOScaleRotate180
            case 270:
                rotation = kIOScaleRotate270
            default:
                return
            }

            let servicePort = id.getIOService()
            if (servicePort != 0) {
                let options = IOOptionBits((kIOFBSetTransform | (rotation) << 16))
                let result = IOServiceRequestProbe(servicePort, options)
                if (result != KERN_SUCCESS) {
                    log.error("Unable to set rotation for: \(self.id):\(self.name): \(result)")
                }
            }
        }
    }

    /// Brightness of the screen between 0.0 and 1.0
    var brightness: Float {
        get {
            var brightness: Float = 0.0
            DisplayServicesGetBrightness(id, &brightness)
            return brightness
        }
        set {
            DisplayServicesSetBrightness(id, newValue)
        }
    }

    /// The current screen mode as a CGSDisplayMode struct. Available struct members are:
    ///   * width - Width of the screen in points
    ///   * height - Height of the screen in points
    ///   * density - The scale of the screen, `1` for native pixel scale, `2` for "Retina" (HiDPI)
    ///   * freq - Vertical refresh rate in Hz
    ///   * depth - Color bit depth of the screen
    var currentScreenMode: CGSDisplayMode {
        get {
            var modeID: Int32 = 0
            var mode = CGSDisplayMode()

            // Fetch information about the screen mode
            CGSGetCurrentDisplayMode(id, &modeID)
            CGSGetDisplayModeDescriptionOfLength(id, modeID, &mode, Int32(MemoryLayout<CGSDisplayMode>.stride))

            return mode
        }
        set {
            // FIXME: Decide if this should be settable. We can do it, but it means no result for the caller
            _ = setScreenMode(newValue)
        }
    }

    /// Set the screen mode
    /// - Parameter mode: A CGSDisplayMode struct, see `currentMode` for information on the struct members
    /// - Returns: True if the operation succeded, otherwise False
    func setScreenMode(_ mode: CGSDisplayMode) -> Bool {
        var config: CGDisplayConfigRef?
        CGBeginDisplayConfiguration(&config)
        CGSConfigureDisplayMode(config, id, Int32(mode.modeNumber))
        return CGCompleteDisplayConfiguration(config, .permanently) == CGError.success
    }

    /// Fetch all of the available screen modes for this screen. Note that not all modes are guaranteed to be valid.
    /// - Returns: An array of CGSDisplayMode structs. See `currentMode` for information on the struct members
    func availableScreenModes() -> [CGSDisplayMode] {
        var info = [CGSDisplayMode]()
        var numModes: Int32 = 0
        CGSGetNumberOfDisplayModes(id, &numModes)

        for index in 0..<numModes {
            var mode = CGSDisplayMode()
            CGSGetDisplayModeDescriptionOfLength(id, index, &mode, Int32(MemoryLayout<CGSDisplayMode>.stride))
            info.append(mode)
        }

        return info
    }
}
